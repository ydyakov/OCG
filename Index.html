<html>
<head>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a2b3c);

        const group = new THREE.Group();
        scene.add(group);

        const centerBox = {
            width: 16,
            height: 12,
            length: 24,
            color: 0xD9C5A3
        };

        const Tower = {
            width: 4,
            height: 16,
            length: 4,
            color: 0xD9C5A3
        };

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-25, 15, 25);
        camera.lookAt(0, 0, 0);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 5);
        scene.add(directionalLight);
        // обакт за зареждане на текстури
        const loader = new THREE.TextureLoader();

        const buildingMaterial = new THREE.MeshStandardMaterial({
            color: centerBox.color
        });

        const roofMaterial = new THREE.MeshStandardMaterial({
            color: 0x5C3327
        });

        const gardenMaterial = new THREE.MeshStandardMaterial({
            color: 0x3A7D34
        });

        const poleMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.5,
            metalness: 0.5
        });

        const windowMaterial = new THREE.MeshStandardMaterial({
            color: 0xffff00,
            emissive: 0xffff00,
            emissiveIntensity: 1
        });

        const columnMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff
        });


        //картинки
        const textureUrl =
        {
            flag: "https://siana1s.github.io/okg/image/zname.png",
            tree1: "https://siana1s.github.io/okg/image/R.png",
            tree2: "https://siana1s.github.io/okg/image/mytree.png"

        }

        const buildingGeometry = new THREE.BoxGeometry(centerBox.width, centerBox.height, centerBox.length);
        const mainBuilding = new THREE.Mesh(buildingGeometry, buildingMaterial);
        mainBuilding.position.set(0, centerBox.height / 2, 0);
        group.add(mainBuilding);

        const roofGeometry = new THREE.ConeGeometry(centerBox.width * 0.9, 4, 4);
        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
        roof.position.set(0, centerBox.height + 2, 0);
        roof.rotation.y = Math.PI / 4;
        group.add(roof);

        const columnGeometry = new THREE.CylinderGeometry(0.6, 0.6, centerBox.height - 3.2, 32);

        const FstColumn = new THREE.Mesh(columnGeometry, columnMaterial);
        FstColumn.position.set(-6, (centerBox.height + 0.7) / 2, centerBox.length / 2 + 0.5);
        group.add(FstColumn);

        const SndColumn = new THREE.Mesh(columnGeometry, columnMaterial);
        SndColumn.position.set(-1.5, (centerBox.height + 0.7) / 2, centerBox.length / 2 + 0.5);
        group.add(SndColumn);

        const ThColumn = new THREE.Mesh(columnGeometry, columnMaterial);
        ThColumn.position.set(2.5, (centerBox.height + 0.7) / 2, centerBox.length / 2 + 0.5);
        group.add(ThColumn);

        const AColumn = new THREE.Mesh(columnGeometry, columnMaterial);
        AColumn.position.set(6, (centerBox.height + 0.7) / 2, centerBox.length / 2 + 0.5);
        group.add(AColumn);

        const stairGeometry = new THREE.BoxGeometry(16, 0.45, 6);
        for (let i = 0; i < 5; i++) {
            const stair = new THREE.Mesh(stairGeometry, buildingMaterial);
            stair.position.set(0, i * 0.3, centerBox.length / 2 + 0.5 - i * 0.5);
            group.add(stair);
        }

        const windowGeometry = new THREE.PlaneGeometry(1, 1.5);

        for (let i = 0; i < 3; i++) {
            const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
            window1.position.set(-4 + i * 4, 5, -centerBox.length / 2 - 0.01);
            group.add(window1);

            const windowLight1 = new THREE.PointLight(0xffff00, 1, 10);
            windowLight1.position.set(-4 + i * 4, 5, -centerBox.length / 2 - 1);
            group.add(windowLight1);
        }


        for (let i = 0; i < 2; i++) {
            const window3 = new THREE.Mesh(windowGeometry, windowMaterial);
            window3.position.set(-centerBox.width / 2 - 0.01, 5, -6 + i * 12);
            window3.rotation.y = Math.PI / 2;
            group.add(window3);

            const windowLight3 = new THREE.PointLight(0xffff00, 1, 10);
            windowLight3.position.set(-centerBox.width / 2 - 1, 5, -6 + i * 12);
            group.add(windowLight3);

            const window4 = new THREE.Mesh(windowGeometry, windowMaterial);
            window4.position.set(centerBox.width / 2 + 0.01, 5, -6 + i * 12);
            window4.rotation.y = -Math.PI / 2;
            group.add(window4);

            const windowLight4 = new THREE.PointLight(0xffff00, 1, 10);
            windowLight4.position.set(centerBox.width / 2 + 1, 5, -6 + i * 12);
            group.add(windowLight4);
        }

        const tower1Geometry = new THREE.BoxGeometry(Tower.width, Tower.height, Tower.length);
        const tower1 = new THREE.Mesh(tower1Geometry, buildingMaterial);
        tower1.position.set(
            -centerBox.width / 2 - Tower.width / 2,
            Tower.height / 2,
            -centerBox.length / 2 - Tower.length / 2
        );
        group.add(tower1);

        const tower1RoofGeometry = new THREE.ConeGeometry(Tower.width * 0.9, 3, 4);
        const tower1Roof = new THREE.Mesh(tower1RoofGeometry, roofMaterial);
        tower1Roof.position.set(
            -centerBox.width / 2 - Tower.width / 2,
            Tower.height + 1.5,
            -centerBox.length / 2 - Tower.length / 2
        );
        tower1Roof.rotation.y = Math.PI / 4;
        group.add(tower1Roof);

        const towerWindowGeometry = new THREE.PlaneGeometry(0.8, 1.2);
        for (let i = 0; i < 3; i++) {
            const towerWindow1 = new THREE.Mesh(towerWindowGeometry, windowMaterial);
            towerWindow1.position.set(
                -centerBox.width / 2 - Tower.width / 2,
                4 + i * 4,
                -centerBox.length / 2 - Tower.length / 2 - 0.01
            );
            group.add(towerWindow1);

            const towerLight1 = new THREE.PointLight(0xffff00, 0.8, 8);
            towerLight1.position.set(
                -centerBox.width / 2 - Tower.width / 2,
                4 + i * 4,
                -centerBox.length / 2 - Tower.length / 2 - 1
            );
            group.add(towerLight1);
        }

        const tower2Geometry = new THREE.BoxGeometry(Tower.width, Tower.height, Tower.length);
        const tower2 = new THREE.Mesh(tower2Geometry, buildingMaterial);
        tower2.position.set(
            centerBox.width / 2 + Tower.width / 2,
            Tower.height / 2,
            -centerBox.length / 2 - Tower.length / 2
        );
        group.add(tower2);

        const tower2RoofGeometry = new THREE.ConeGeometry(Tower.width * 0.9, 3, 4);
        const tower2Roof = new THREE.Mesh(tower2RoofGeometry, roofMaterial);
        tower2Roof.position.set(
            centerBox.width / 2 + Tower.width / 2,
            Tower.height + 1.5,
            -centerBox.length / 2 - Tower.length / 2
        );
        tower2Roof.rotation.y = Math.PI / 4;
        group.add(tower2Roof);

        for (let i = 0; i < 3; i++) {
            const towerWindow2 = new THREE.Mesh(towerWindowGeometry, windowMaterial);
            towerWindow2.position.set(
                centerBox.width / 2 + Tower.width / 2,
                4 + i * 4,
                -centerBox.length / 2 - Tower.length / 2 - 0.01
            );
            group.add(towerWindow2);

            const towerLight2 = new THREE.PointLight(0xffff00, 0.8, 8);
            towerLight2.position.set(
                centerBox.width / 2 + Tower.width / 2,
                4 + i * 4,
                -centerBox.length / 2 - Tower.length / 2 - 1
            );
            group.add(towerLight2);
        }

        const tower3Geometry = new THREE.BoxGeometry(Tower.width, Tower.height, Tower.length);
        const tower3 = new THREE.Mesh(tower3Geometry, buildingMaterial);
        tower3.position.set(
            -centerBox.width / 2 - Tower.width / 2,
            Tower.height / 2,
            centerBox.length / 2 + Tower.length / 2
        );
        group.add(tower3);

        const tower3RoofGeometry = new THREE.ConeGeometry(Tower.width * 0.9, 3, 4);
        const tower3Roof = new THREE.Mesh(tower3RoofGeometry, roofMaterial);
        tower3Roof.position.set(
            -centerBox.width / 2 - Tower.width / 2,
            Tower.height + 1.5,
            centerBox.length / 2 + Tower.length / 2
        );
        tower3Roof.rotation.y = Math.PI / 4;
        group.add(tower3Roof);

        const tower4Geometry = new THREE.BoxGeometry(Tower.width, Tower.height, Tower.length);
        const tower4 = new THREE.Mesh(tower4Geometry, buildingMaterial);
        tower4.position.set(
            centerBox.width / 2 + Tower.width / 2,
            Tower.height / 2,
            centerBox.length / 2 + Tower.length / 2
        );
        group.add(tower4);

        const tower4RoofGeometry = new THREE.ConeGeometry(Tower.width * 0.9, 3, 4);
        const tower4Roof = new THREE.Mesh(tower4RoofGeometry, roofMaterial);
        tower4Roof.position.set(
            centerBox.width / 2 + Tower.width / 2,
            Tower.height + 1.5,
            centerBox.length / 2 + Tower.length / 2
        );
        tower4Roof.rotation.y = Math.PI / 4;
        group.add(tower4Roof);

        //цъллиндер
        const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 18, 16);
        const pole = new THREE.Mesh(poleGeometry, poleMaterial);
        pole.position.set(17, 9, centerBox.length / 2 + 8);
        group.add(pole);

        const baner1Geometry = new THREE.PlaneGeometry(6, 5);
        const baner1Material = new THREE.MeshStandardMaterial({ map: loader.load(textureUrl.flag), side: THREE.DoubleSide });
        const baner1 = new THREE.Mesh(baner1Geometry, baner1Material);
        group.add(baner1);
        baner1.position.set(20, 15.5, centerBox.length / 2 + 8);

        const gardenGeometry = new THREE.PlaneGeometry(100, 100);
        const garden = new THREE.Mesh(gardenGeometry, gardenMaterial);
        garden.rotation.x = -Math.PI / 2;
        group.add(garden);


        const treeMaterial = new THREE.MeshStandardMaterial({ map: loader.load(textureUrl.tree2), side: THREE.DoubleSide, transparent: true, });
        const treeGeometry = new THREE.PlaneGeometry(5, 15);
        const tree2 = new THREE.Mesh(treeGeometry, treeMaterial);
        tree2.position.set(-16, 7.5, centerBox.length / 2 + 5)
        const tree3 = tree2.clone();
        tree3.rotation.y = Math.PI / 2;
        group.add(tree2, tree3);


        // Арка
        const arkShape = new THREE.Shape();
        arkShape.moveTo(0, 1);     // върхът горе
        arkShape.lineTo(-1, -1);   // лява долна точка
        arkShape.lineTo(1, -1);    // дясна долна точка
        arkShape.lineTo(0, 1);     // обратно към върха
               
        const extrudeSettings = {
            depth: 1,           
            bevelEnabled: false   
        };
                // Създаване на геометрията
        const arkShapeExtrure = new THREE.ExtrudeGeometry(arkShape, extrudeSettings);

        // Материал (полупрозрачен)
        const arkMaterial = new THREE.MeshStandardMaterial({
            color: 'white',
            side: THREE.DoubleSide 
        });

        const arkPrism = new THREE.Mesh(arkShapeExtrure, arkMaterial);
        arkPrism.position.set(0, (centerBox.height + 0.7), centerBox.length / 2 + 0.5)
        group.add(arkPrism);

        function animate() {
            requestAnimationFrame(animate);

            group.rotation.y += 0.005;

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', onWindowResize);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>